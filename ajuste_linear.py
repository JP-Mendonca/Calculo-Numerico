# -*- coding: utf-8 -*-
"""Ajuste linear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/116OD6lKxTpqktilmuXLK64BgzHXcjUMp

1) (0,5 pontos) Uma empresa de construção civil projetou uma sala de cinema cuja sustentação deve
ser garantida por quatro colunas principais. Após uma série de medidas, os técnicos da empresa
obtiveram um conjunto de valores que podem ser expressos de acordo com o seguinte sistema de
equações lineares:

23,21x + 7,89y + 4,95z + 6,35w = 32,67

8,05x + 14,7y + 5,05z + 1,25w = 22,27

2,02x + 7,77y + 23,04z + 6,72w = 29,84

0,32x + 6,05y + 4,77z + 14,78w = 19,67

Sendo você a pessoa contratada por esta empresa para atuar na área de modelagem e simulação de
dados, resolva o sistema acima empregando o método de Gauss-Seidel visando encontrar o diâmetro
(em metros) de cada uma das colunas (x, y, z e w). Para tal use uma precisão de 10-4.
"""

from math import sqrt

# método de gauss-seidel

def gauss_jacobi(x_inicial, matriz, erro):

    n = len(matriz)

    x_temp = []
    for x in range(n):
        x_temp.append(-1)

    # verifica se o número de incógnitas do chute inicial é o mesmo do número de equações
    if len(x_inicial) != n:
        print("O número de incógnitas deve ser igual ao número de equações, entre com a quantidade correta de chutes iniciais.")
        return x_temp
        
    # verifica se a diagonal principal é nula
    for i in range(n):
        if matriz[i][i] == 0:
            print("A diagonal principal não pode conter zeros.")
            return x_temp

    n = len(matriz)
    x_temp = x_inicial.copy()      # i
    x_result = x_temp.copy()       # i+1
    cont = 0
    while True:
        for l in range(n):
            soma = 0
            soma += matriz[l][n]
            for c in range(n):
                # se não estiver na coluna da diagonal principal
                if c != l:
                    soma -= matriz[l][c]*x_temp[c]
            x_result[l] = soma/matriz[l][l]
        
        # verifica a condição de parada para a solução encontra até então

        terminou = True
        for i in range(n):
            _erro = abs((x_result[i] - x_temp[i])/x_result[i])
            if _erro > erro:
                terminou = False
        cont += 1
        if terminou:
            break
        x_temp = x_result.copy()
    print("Número de iterações:", cont)
    return x_result

def gauss_seidel(x_inicial, matriz, erro):

    n = len(matriz)

    x_temp = []
    for x in range(n):
        x_temp.append(-1)

    # verifica se o número de incógnitas do chute inicial é o mesmo do número de equações
    if len(x_inicial) != n:
        print("O número de incógnitas deve ser igual ao número de equações, entre com a quantidade correta de chutes iniciais.")
        return x_temp
        
    # verifica se a diagonal principal é nula
    for i in range(n):
        if matriz[i][i] == 0:
            print("A diagonal principal não pode conter zeros.")
            return x_temp

    n = len(matriz)
    x_temp = x_inicial.copy()      # i
    x_result = x_temp.copy()       # i+1
    cont = 0
    while True:
        for l in range(n):
            soma = 0
            soma += matriz[l][n]
            for c in range(n):
                # se não estiver na coluna da diagonal principal
                if c != l:
                    soma -= matriz[l][c]*x_result[c]
            x_result[l] = soma/matriz[l][l]
        
        # verifica a condição de parada para a solução encontra até então

        terminou = True
        for i in range(n):
            _erro = abs((x_result[i] - x_temp[i])/x_result[i])
            if _erro > erro:
                terminou = False
        cont += 1
        if terminou:
            break
        x_temp = x_result.copy()
    print("Número de iterações:", cont)
    return x_result

matriz = [[23.21, 7.89, 4.95, 6.35, 32.67],[8.05, 14.7, 5.05, 1.25, 22.27],[2.02, 7.77, 23.04, 6.72, 29.84], [0.32, 6.05, 4.77, 14.78, 19.67]]

x_inicial = []
for i in range(len(matriz)):
  x_inicial.append(0)

# print("Método de gauss-jacobi:")
# print(gauss_jacobi(x_inicial,matriz, 10**-4))
# print()
print("Método de gauss-seidel:")
result = gauss_seidel(x_inicial,matriz, 10**-4)
print("X =", result[0],"- Y =",result[1], "- Z =", result[2], "- W =", result[3])

"""2) (0,5 pontos) Um estudo feito pela prefeitura de Aracaju foi conduzido para determinar um projeto
adequado de ciclovias ao longo das principais avenidas. Foram coletados dados sobre a largura das
ciclovias e a distância média entre as bicicletas e os carros trafegando pelas avenidas. Os dados de
nove avenidas são:

Distância (m) 2,4 1,5 2,4 1,8 1,8 2,9 1,2 3,0 1,2

Largura (m) 2,9 2,1 2,3 2,1 1,8 2,7 1,5 2,9 1,5

Empregando regressão linear pelo método dos Mínimos quadrados, ajuste uma reta aos dados
tabelados. Calcule o coeficiente de correlação mostrando a qualidade do ajuste. Após encontrada a
reta de melhor ajuste, encontre a largura mínima da ciclovia para quando a distância entre os
veículos e ciclistas trafegando for de 1,8 m.
"""

def minimos_quadrados(valores_x, valores_y):

  # calculo do ajuste
  somatorio_xi2 = 0
  somatorio_xi = 0

  somatorio_xy = 0
  indice_y = 0
  somatorio_y = 0
  
  for v in valores_x:
    somatorio_xi2 += v**2
    somatorio_xi += v

    somatorio_xy += v*valores_y[indice_y]
    somatorio_y += valores_y[indice_y]
    indice_y += 1

  n = indice_y

  linha1 = [somatorio_xi2, somatorio_xi, somatorio_xy]
  linha2 = [somatorio_xi, n, somatorio_y]

  m = [linha1, linha2]
  x_inicial = [0,0]

  r = gauss_seidel(x_inicial, m, 10**-5)

  a = r[0]
  b = r[1]

  # calculo do coeficiente de correlação (qualidade do ajuste)
  # quanto mais próximo de 1 melhor

  Sr = 0
  media = 0

  for i in range(len(valores_x)):
    Sr += (valores_y[i] - b - a*valores_x[i])**2
    media += valores_y[i]

  media = media/len(valores_y)
  St = 0

  for i in range(len(valores_y)):
    St += (valores_y[i] - media)**2

  R = sqrt((St - Sr)/St)

  print("R =", R)
  print("R^2 =", R**2)

  #Após encontrada a reta de melhor ajuste, encontre a largura mínima da ciclovia 
  #para quando a distância entre os veículos e ciclistas trafegando for de 1,8 m.

  largura = a*1.8 + b
  print("Largura mínima para distância igual a 1.8m:", largura)

  return a, b

# 88,9    108,5  104,1   139,7    127     94      116,8   99,1
# 14,6    16,7   15,3    23,2     19,5    16,1    18,1    16,6

eq1 = [88.9, 108.5, 104.1, 139.7, 127, 94, 116.8, 99.1]
eq2 = [16.7, 15.3, 23.2, 19.5, 16.1, 18.1, 16.6]
a, b = minimos_quadrados(eq1, eq2)
print("Equação da reta: y =", a, "*x +", b)